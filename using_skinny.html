<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Skinny-C: Using Skinny-C</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Skinny-C
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Using Skinny-C </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="using_ctr"></a>
CTR mode</h1>
<p>The API for Skinny-C provides <a class="el" href="classCTR.html" title="Implementation of the Counter (CTR) mode for 128-bit block ciphers. ">CTR</a> mode for bulk encryption of arbitrarily-sized data blocks. The first step is to initialize the <a class="el" href="classCTR.html" title="Implementation of the Counter (CTR) mode for 128-bit block ciphers. ">CTR</a> control structure with the key. For this example we will use a 256-bit key with <a class="el" href="classSkinny128.html" title="Abstract base class for SKINNY block ciphers with 128-bit blocks. ">Skinny128</a>:</p>
<div class="fragment"><div class="line"><a class="code" href="structSkinny128CTR__t.html">Skinny128CTR_t</a> ctr;</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> key[32] = ...;</div>
<div class="line"><a class="code" href="group__skinny128.html#gad8bc5eb97099bcadeba9552c069eab3d">skinny128_ctr_init</a>(&amp;ctr);</div>
<div class="line"><a class="code" href="group__skinny128.html#gabdc400daf6e869e79d6d452f1521d0bd">skinny128_ctr_set_key</a>(&amp;ctr, key, 32);</div>
</div><!-- fragment --><p>The <a class="el" href="group__skinny128.html#gad8bc5eb97099bcadeba9552c069eab3d" title="Initializes Skinny-128 in CTR mode. ">skinny128_ctr_init()</a> function chooses the best <a class="el" href="classCTR.html" title="Implementation of the Counter (CTR) mode for 128-bit block ciphers. ">CTR</a> mode implementation for your platform at runtime. For example, the AVX2 backend will be used if your CPU supports AVX2 and the library was compiled with AVX2 support enabled.</p>
<p>The next step is to set the counter value for the current data block. Counter values are typically formed by combining a packet sequence number with an offset into the packet. It is very important that the counter values be different from one packet to the next.</p>
<p>The following is an example of setting the initial counter value based on a 32-bit packet sequence number:</p>
<div class="fragment"><div class="line">uint32_t seqnum = ...;</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> counter[16];</div>
<div class="line">memset(counter, 0, <span class="keyword">sizeof</span>(counter));</div>
<div class="line">counter[0] = (<span class="keywordtype">unsigned</span> char)(seqnum &gt;&gt; 24);</div>
<div class="line">counter[1] = (<span class="keywordtype">unsigned</span> char)(seqnum &gt;&gt; 16);</div>
<div class="line">counter[2] = (<span class="keywordtype">unsigned</span> char)(seqnum &gt;&gt; 8);</div>
<div class="line">counter[3] = (<span class="keywordtype">unsigned</span> char)seqnum;</div>
<div class="line"><a class="code" href="group__skinny128.html#ga53ce0b454ce6892b4846db9b6d5a0cdd">skinny128_ctr_set_counter</a>(&amp;ctr, counter, <span class="keyword">sizeof</span>(counter));</div>
</div><!-- fragment --><p>The bytes at the end of the counter value will be incremented each time <a class="el" href="classCTR.html" title="Implementation of the Counter (CTR) mode for 128-bit block ciphers. ">CTR</a> mode needs a new 128-bit block of encrypted data. In this example there are 12 bytes available for incrementing.</p>
<p>If your application processes large amounts of data, then there is a risk that the sequence number might roll around. If this is the case, then you should use a 64-bit sequence number, or abort the connection when the sequence number rolls around, or both.</p>
<p>Encryption of packets is accomplished as follows:</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> packet[MAX_PACKET_SIZE] = ...;</div>
<div class="line"><a class="code" href="group__skinny128.html#ga98250043e8ca6f59966a55c03029d3ec">skinny128_ctr_encrypt</a>(packet, packet, size, &amp;ctr);</div>
</div><!-- fragment --><p>The first two parameters are the output buffer for the ciphertext and the input buffer for the plaintext. In this example we are encrypting the data in-place within the same buffer but they can be different.</p>
<p>To encrypt the next packet, increment the sequence number and then call <a class="el" href="group__skinny128.html#ga53ce0b454ce6892b4846db9b6d5a0cdd" title="Sets the counter value in a Skinny-128 CTR control block. ">skinny128_ctr_set_counter()</a> and <a class="el" href="group__skinny128.html#ga98250043e8ca6f59966a55c03029d3ec" title="Encrypt a block of data using Skinny-128 in CTR mode. ">skinny128_ctr_encrypt()</a> again.</p>
<p>In <a class="el" href="classCTR.html" title="Implementation of the Counter (CTR) mode for 128-bit block ciphers. ">CTR</a> mode, decryption and encryption are identical operations, so there is no "decrypt" function in the <a class="el" href="classCTR.html" title="Implementation of the Counter (CTR) mode for 128-bit block ciphers. ">CTR</a> API. Use <a class="el" href="group__skinny128.html#ga98250043e8ca6f59966a55c03029d3ec" title="Encrypt a block of data using Skinny-128 in CTR mode. ">skinny128_ctr_encrypt()</a>.</p>
<p>Once you have finished encrypting all packets, you should clean up the <a class="el" href="classCTR.html" title="Implementation of the Counter (CTR) mode for 128-bit block ciphers. ">CTR</a> control structure to free any dyanmically-allocated memory that was allocated by <a class="el" href="group__skinny128.html#gad8bc5eb97099bcadeba9552c069eab3d" title="Initializes Skinny-128 in CTR mode. ">skinny128_ctr_init()</a>:</p>
<div class="fragment"><div class="line"><a class="code" href="group__skinny128.html#ga56db1865bdecb8f59fc1c06f877b7c15">skinny128_ctr_cleanup</a>(&amp;ctr);</div>
</div><!-- fragment --><h1><a class="anchor" id="using_ctr_tweak"></a>
CTR mode with per-packet tweaks</h1>
<p>SKINNY is a tweakable block cipher, so it is possible to encrypt packets with <a class="el" href="classCTR.html" title="Implementation of the Counter (CTR) mode for 128-bit block ciphers. ">CTR</a> mode in a slightly different way. Instead of passing the sequence number in as part of the counter block, the sequence number can be provided as a per-packet tweak.</p>
<p>This is definitely useful when encrypting packets with <a class="el" href="classSkinny64.html" title="Abstract base class for SKINNY block ciphers with 64-bit blocks. ">Skinny64</a> or Mantis as the 64-bit counter value is not large enough to contain both a 64-bit sequence number and a packet offset.</p>
<p>As before, we start by initializing the 128-bit key and the <a class="el" href="classCTR.html" title="Implementation of the Counter (CTR) mode for 128-bit block ciphers. ">CTR</a> control structure with <a class="el" href="classSkinny64.html" title="Abstract base class for SKINNY block ciphers with 64-bit blocks. ">Skinny64</a>:</p>
<div class="fragment"><div class="line"><a class="code" href="structSkinny64CTR__t.html">Skinny64CTR_t</a> ctr;</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> key[16] = ...;</div>
<div class="line"><a class="code" href="group__skinny64.html#ga52d9c06ae47fd0e91bdf393a33ffbf91">skinny64_ctr_init</a>(&amp;ctr);</div>
<div class="line"><a class="code" href="group__skinny64.html#ga5d56b6209923a6a61a3b41b0cbc559ab">skinny64_ctr_set_tweaked_key</a>(&amp;ctr, key, 16);</div>
</div><!-- fragment --><p>For each packet, the sequence number is provided as the tweak and the counter value is reset to all-zeroes:</p>
<div class="fragment"><div class="line">uint64_t seqnum = ...;</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> seqbuf[8];</div>
<div class="line">seqbuf[0] = (<span class="keywordtype">unsigned</span> char)(seqnum &gt;&gt; 56);</div>
<div class="line">seqbuf[1] = (<span class="keywordtype">unsigned</span> char)(seqnum &gt;&gt; 48);</div>
<div class="line">seqbuf[2] = (<span class="keywordtype">unsigned</span> char)(seqnum &gt;&gt; 40);</div>
<div class="line">seqbuf[3] = (<span class="keywordtype">unsigned</span> char)(seqnum &gt;&gt; 32);</div>
<div class="line">seqbuf[4] = (<span class="keywordtype">unsigned</span> char)(seqnum &gt;&gt; 24);</div>
<div class="line">seqbuf[5] = (<span class="keywordtype">unsigned</span> char)(seqnum &gt;&gt; 16);</div>
<div class="line">seqbuf[6] = (<span class="keywordtype">unsigned</span> char)(seqnum &gt;&gt; 8);</div>
<div class="line">seqbuf[7] = (<span class="keywordtype">unsigned</span> char)seqnum;</div>
<div class="line"><a class="code" href="group__skinny64.html#ga8081890d0b1f76fb83650707b7001a08">skinny64_ctr_set_tweak</a>(&amp;ctr, seqbuf, <span class="keyword">sizeof</span>(seqbuf));</div>
<div class="line"><a class="code" href="group__skinny64.html#gafeab5ea3daefe64c9cebb87d97af4fb7">skinny64_ctr_set_counter</a>(&amp;ctr, NULL, 0);</div>
</div><!-- fragment --><p>Packet encryption is similar to before:</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> packet[MAX_PACKET_SIZE] = ...;</div>
<div class="line"><a class="code" href="group__skinny64.html#ga7c186d7f18e759b5d6718f38e3d1f53a">skinny64_ctr_encrypt</a>(packet, packet, size, &amp;ctr);</div>
</div><!-- fragment --><p>Finally, clean up when the session ends:</p>
<div class="fragment"><div class="line"><a class="code" href="group__skinny64.html#ga4551588627513d5048083a7790f34cef">skinny64_ctr_cleanup</a>(&amp;ctr);</div>
</div><!-- fragment --><h1><a class="anchor" id="using_ecb"></a>
ECB mode</h1>
<dl class="section note"><dt>Note</dt><dd>ECB mode can be unsafe when used to directly encrypt bulk data if you don't know what you are doing. Applications should use higher-level modes such as <a class="el" href="classCTR.html" title="Implementation of the Counter (CTR) mode for 128-bit block ciphers. ">CTR</a>, CBC, EAX, GCM, etc when handling bulk data. Failure to do this may compromise the security of the application.</dd></dl>
<p>The API for Skinny-C provides ECB encryption on a block-by-block basis. The first step is to initialize the key schedule using the key. For this example we will use a 256-bit key with <a class="el" href="classSkinny128.html" title="Abstract base class for SKINNY block ciphers with 128-bit blocks. ">Skinny128</a>:</p>
<div class="fragment"><div class="line"><a class="code" href="structSkinny128Key__t.html">Skinny128Key_t</a> ks;</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> key[32] = ...;</div>
<div class="line"><a class="code" href="group__skinny128.html#gaf31bffdf417e3242b54e664f3d59751a">skinny128_set_key</a>(&amp;ks, key, 32);</div>
</div><!-- fragment --><p>Each block of the plaintext is then encrypted as follows:</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> plaintext[16] = ...;</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> ciphertext[16];</div>
<div class="line"><a class="code" href="group__skinny128.html#ga79500329f585c970ec3b75331f3699ce">skinny128_ecb_encrypt</a>(ciphertext, plaintext, &amp;ks);</div>
</div><!-- fragment --><p>To decrypt a ciphertext back to the original plaintext:</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> ciphertext[16] = ...;</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> plaintext[16];</div>
<div class="line"><a class="code" href="group__skinny128.html#ga9ccdfab6dc540fbbc34b44a9538d5651">skinny128_ecb_decrypt</a>(plaintext, ciphertext, &amp;ks);</div>
</div><!-- fragment --><h1><a class="anchor" id="using_parallel_ecb"></a>
Parallel ECB mode</h1>
<p>The API for Skinny-C provides an alternative ECB interface that encrypts multiple blocks in parallel on platforms that have SIMD instruction support. This can be useful for implementing block cipher modes like <a href="https://en.wikipedia.org/wiki/OCB_mode">OCB</a> that operate on blocks in parallel.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="using_skinny.html#using_ctr">CTR mode</a> also encrypts multiple blocks in parallel when SIMD support is available. There is dedicated support for <a class="el" href="classCTR.html" title="Implementation of the Counter (CTR) mode for 128-bit block ciphers. ">CTR</a> mode in the library so it isn't necessary to use the parallel ECB API for <a class="el" href="classCTR.html" title="Implementation of the Counter (CTR) mode for 128-bit block ciphers. ">CTR</a>.</dd></dl>
<p>To perform parallel encryption, we start by initializing the parallel ECB context and then set the key:</p>
<div class="fragment"><div class="line"><a class="code" href="structSkinny128ParallelECB__t.html">Skinny128ParallelECB_t</a> ecb;</div>
<div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> key[32] = ...;</div>
<div class="line"><a class="code" href="group__skinny128.html#gac74cbc82f842165d63a90a3971e28415">skinny128_parallel_ecb_init</a>(&amp;ecb);</div>
<div class="line"><a class="code" href="group__skinny128.html#ga6eda4a097e289f2e7c5cf47b8d4f53da">skinny128_parallel_ecb_set_key</a>(&amp;ecb, key, 32);</div>
</div><!-- fragment --><p>The <a class="el" href="group__skinny128.html#gac74cbc82f842165d63a90a3971e28415" title="Initializes Skinny-128 in parallel ECB mode. ">skinny128_parallel_ecb_init()</a> function chooses the best parallel ECB implementation for your platform at runtime. For example, the AVX2 backend will be used if your CPU supports AVX2 and the library was compiled with AVX2 support enabled.</p>
<p>Encryption of eight blocks at a time is accomplished as follows (decryption is similar):</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> blocks[8 * <a class="code" href="group__skinny128.html#ga5f34e79e8a76d180e25d4e55b6a3c92d">SKINNY128_BLOCK_SIZE</a>] = ...;</div>
<div class="line"><a class="code" href="group__skinny128.html#ga1fb57f4e11ceaac54eda38f79d39f02e">skinny128_parallel_ecb_encrypt</a>(blocks, blocks, <span class="keyword">sizeof</span>(blocks), &amp;ecb);</div>
</div><!-- fragment --><p>The first two parameters are the output buffer for the ciphertext and the input buffer for the plaintext. In this example we are encrypting the data in-place within the same buffer but they can be different.</p>
<p>The amount of parallelism is dependent upon the specific back end implementation. The best parallel block size (in bytes) is given by <code>ecb.parallel_size</code>. This can be used to tune the parallel block size at runtime.</p>
<p>Once you have finished encrypting or decrypting data, you should clean up the parallel ECB control structure to free any dyanmically-allocated memory that was allocated by <a class="el" href="group__skinny128.html#gac74cbc82f842165d63a90a3971e28415" title="Initializes Skinny-128 in parallel ECB mode. ">skinny128_parallel_ecb_init()</a>:</p>
<div class="fragment"><div class="line"><a class="code" href="group__skinny128.html#ga46c84618772e28352be43c2a092ff0d4">skinny128_parallel_ecb_cleanup</a>(&amp;ecb);</div>
</div><!-- fragment --> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Apr 8 2018 13:55:24 for Skinny-C by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
